<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SwiftRex - SwiftRex</title>
    <link rel="stylesheet" type="text/css" href="/all.css" media="all" />
</head>
<body>
    <header>
        <a href="/">
            <strong>
                SwiftRex
            </strong>
            <span>Documentation</span>
        </a>
        <sup>Beta</sup>
    </header>

    <!--
    <form class="search">
        <input type="search" placeholder="Search" />
    </form>
    -->

    <nav>
        <div class="wrapper">
            <h2>On This Page</h2>
            <ol><li><a href="#classes">Classes</a></li><li><a href="#structures">Structures</a></li><li><a href="#enumerations">Enumerations</a></li><li><a href="#protocols">Protocols</a></li><li><a href="#typealiases">Typealiases</a></li></ol>
        </div>
    </nav>

    <main>
        <article>
                <section id="classes">
        <h2>Classes</h2>
        <dl>
            <dt class="class">
    <a href="/EffectMiddleware" title="class - EffectMiddleware">
        Effect‚ÄãMiddleware
    </a>
</dt>
<dd>
    <p>Easiest way to implement a <code>Middleware</code>, with a single function that gives you all you need, and from which you can return an <code>Effect</code>.</p>

</dd>
<dt class="class">
    <a href="/ObservableViewModel" title="class - ObservableViewModel">
        Observable‚ÄãView‚ÄãModel
    </a>
</dt>
<dd>
    <p>A Store Projection made to be used in SwiftUI</p>

</dd>
<dt class="class">
    <a href="/EffectMiddleware" title="class - EffectMiddleware">
        Effect‚ÄãMiddleware
    </a>
</dt>
<dd>
    <p>Easiest way to implement a <code>Middleware</code>, with a single function that gives you all you need, and from which you can return an <code>Effect</code>.</p>

</dd>
<dt class="class">
    <a href="/EffectMiddleware" title="class - EffectMiddleware">
        Effect‚ÄãMiddleware
    </a>
</dt>
<dd>
    <p>Easiest way to implement a <code>Middleware</code>, with a single function that gives you all you need, and from which you can return an <code>Effect</code>.</p>

</dd>
<dt class="class">
    <a href="/ReduxStoreBase" title="class - ReduxStoreBase">
        Redux‚ÄãStore‚ÄãBase
    </a>
</dt>
<dd>
    <p>üè™ <code>ReduxStoreBase</code> is a base class that can be used to create the main store of an app, using the redux pattern.</p>

</dd>
        </dl>
    </section>
    <section id="structures">
        <h2>Structures</h2>
        <dl>
            <dt class="structure">
    <a href="/Effect" title="structure - Effect">
        Effect
    </a>
</dt>
<dd>
    
</dd>
<dt class="structure">
    <a href="/FireAndForget" title="structure - FireAndForget">
        Fire‚ÄãAnd‚ÄãForget
    </a>
</dt>
<dd>
    <p>Fire And Forget is a publisher for when you don't care about the output of certain async operation. It's important to notice that this operation
can't fail. If you want to also ignore the failure, then you can catchErrors and return nil in the proper init.
It may complete successfully when task is done.</p>

</dd>
<dt class="structure">
    <a href="/Effect" title="structure - Effect">
        Effect
    </a>
</dt>
<dd>
    
</dd>
<dt class="structure">
    <a href="/FireAndForget" title="structure - FireAndForget">
        Fire‚ÄãAnd‚ÄãForget
    </a>
</dt>
<dd>
    <p>Fire And Forget is a SignalProducer for when you don't care about the output of certain async operation. It's important to notice that this
operation can't fail. If you want to also ignore the failure, then you can catchErrors and return nil in the proper init.
It may complete successfully when task is done.</p>

</dd>
<dt class="structure">
    <a href="/Effect" title="structure - Effect">
        Effect
    </a>
</dt>
<dd>
    
</dd>
<dt class="structure">
    <a href="/FireAndForget" title="structure - FireAndForget">
        Fire‚ÄãAnd‚ÄãForget
    </a>
</dt>
<dd>
    <p>Fire And Forget is an observable for when you don't care about the output of certain async operation. It's important to notice that this operation
can't fail. If you want to also ignore the failure, then you can catchErrors and return nil in the proper init.
It may complete successfully when task is done.</p>

</dd>
<dt class="structure">
    <a href="/AfterReducer" title="structure - AfterReducer">
        After‚ÄãReducer
    </a>
</dt>
<dd>
    <p>Wraps a closure that will be called after the Reducer pipeline has changed the state with the current action.
With this structure, a middleware can schedule some callback to be executed with the new state, and evidently access this state to check what's
different. This can be very useful for Middlewares that perform logging, monitoring or telemetry, so you can check the state before and after
reducers' execution, or how much time it took for the whole chain to be called (in case this middleware is the first in the chain, of course).
<code>AfterReducer</code> is a monoid, that means it can be combined with another <code>AfterReducer</code> to form a new one (that executes both operations in the
reverse order) and an identity instance, that when combined with any other <code>AfterReducer</code> changes nothing in the result, acting as a neutral
element in composition. The identity of an <code>AfterReducer</code> is the static instance <code>doNothing()</code>, that contains an empty closure for no-op.
The combination between two <code>AfterReducer</code> instances occur in reverse order so the first middleware will have its &quot;after reducer&quot; closure executed
last. This composition can be achieved by using the operator <code>&lt;&gt;</code></p>

</dd>
<dt class="structure">
    <a href="/AnyMiddleware" title="structure - AnyMiddleware">
        Any‚ÄãMiddleware
    </a>
</dt>
<dd>
    <p>Erases the protocol <code>Middleware</code>. Please check its documentation for more information.</p>

</dd>
<dt class="structure">
    <a href="/Reducer" title="structure - Reducer">
        Reducer
    </a>
</dt>
<dd>
    <p>‚öô <code>Reducer</code> is a pure function wrapped in a monoid container, that takes an action and the current state to calculate
the new state.</p>

</dd>
<dt class="structure">
    <a href="/AnyActionHandler" title="structure - AnyActionHandler">
        Any‚ÄãAction‚ÄãHandler
    </a>
</dt>
<dd>
    <p><code>ActionHandler</code> defines a protocol for entities able to handle actions - defined by the associated type <code>ActionType</code>
and <code>AnyActionHandler</code> erases this protocol to a generic struct type.</p>

</dd>
<dt class="structure">
    <a href="/ActionSource" title="structure - ActionSource">
        Action‚ÄãSource
    </a>
</dt>
<dd>
    <p>Representation of the entity responsible for creating and dispatching the action, including information useful for logging, debugging, analytics
or monitoring. The action source will be implicitly created when <code>ActionHandler.dispatch</code> is called from a middleware, view or presenter, and
it will contain the file, function and line from where the dispatch function was called. Additionally you can append extra information useful
for debugging, as an optional String attached to the ActionSource.</p>

</dd>
<dt class="structure">
    <a href="/DispatchedAction" title="structure - DispatchedAction">
        Dispatched‚ÄãAction
    </a>
</dt>
<dd>
    <p>Wraps an action and the information about its dispatcher. It can be used when reactive pipelines want to enforce that the result is an action
while keeping track about the source of that action. For example, certain RxSwift, Combine or ReactiveSwift pipeline want to send actions to the
store and because ActionHandler has a function <code>dispatch(_ action: ActionType, from dispatcher: ActionSource)</code>, that pipeline should output a
<code>DispatchedAction&lt;Action&gt;</code> to fulfil everything needed by the ActionHandler to feed that action into the store.</p>

</dd>
<dt class="structure">
    <a href="/AnyStateProvider" title="structure - AnyStateProvider">
        Any‚ÄãState‚ÄãProvider
    </a>
</dt>
<dd>
    <p><code>AnyStateProvider</code> erases the protocol <code>StateProvider</code>, which defines a entities able to offer state publishers (Combine Publisher, RxSwift
Observable, ReactiveSwift SignalProducer) of certain <code>StateType</code>, so everybody can observe the global state changes through this container. Usually
a <code>Store</code> will implement that, but it can also be a <code>StoreProjection</code> with a state that is derived from the global source-of-truth.</p>

</dd>
<dt class="structure">
    <a href="/AnyStoreType" title="structure - AnyStoreType">
        Any‚ÄãStore‚ÄãType
    </a>
</dt>
<dd>
    
</dd>
<dt class="structure">
    <a href="/ReduxPipelineWrapper" title="structure - ReduxPipelineWrapper">
        Redux‚ÄãPipeline‚ÄãWrapper
    </a>
</dt>
<dd>
    
</dd>
<dt class="structure">
    <a href="/MiddlewareReader" title="structure - MiddlewareReader">
        Middleware‚ÄãReader
    </a>
</dt>
<dd>
    <p>A MiddlewareReader is a way to lazily inject dependencies into a Middleware. For example, you may want to compose multiple middlewares but from
a library, and in this library you don't have the dependencies to inject just yet, because these dependencies are only present in the main target.
That way, instead of creating the middlewares (which would require all the dependencies), you can wrap their initializers in a MiddlewareReader.
The middleware reader is not a middleware, is a a factory (in OOP terms) from <code>(Dependencies) -&gt; MiddlewareType</code> (in FP approach). The benefit
of wrapping the middleware initializers in a MiddlewareReader is that, for all means, MiddlewareReaders can be composed as Middlewares, can be
lifted as Middlewares, but all of this without in fact creating the Middlewares.
Your library can then expose a single MiddlewareReader as public, and you keep all its middlewares as internal classes. From the main target you
compose this MiddlewareReader with other MiddlewareReaders coming from other libraries and from the main target itself. Somewhere where you create
the Store, you finally inject the dependencies at once and you materialize all your middlewares at the same time.
Remember that &quot;inject then compose&quot; is the same as &quot;compose then inject&quot;, but while the former needs dependencies upfront, the latter is more
flexible for being lazy.
For those familiar with Functional Programming, this is similar to Reader Monad, but as SwiftRex recommends dependencies only on Middlewares,
this Reader works specifically with Middlewares.</p>

</dd>
<dt class="structure">
    <a href="/ElementIDAction" title="structure - ElementIDAction">
        Element‚ÄãIDAction
    </a>
</dt>
<dd>
    
</dd>
<dt class="structure">
    <a href="/ElementIndexAction" title="structure - ElementIndexAction">
        Element‚ÄãIndex‚ÄãAction
    </a>
</dt>
<dd>
    
</dd>
<dt class="structure">
    <a href="/SubscriberType" title="structure - SubscriberType">
        Subscriber‚ÄãType
    </a>
</dt>
<dd>
    <p>Abstraction over subscriber/observer types from reactive frameworks.
This abstraction uses concept similar to type-erasure or protocol witness pattern, wrapping the behaviour of concrete implementations and
delegating to them once the wrapper funcions are called.</p>

</dd>
<dt class="structure">
    <a href="/PublisherType" title="structure - PublisherType">
        Publisher‚ÄãType
    </a>
</dt>
<dd>
    <p>Abstraction over publisher/observable/signal producer types from reactive frameworks.
This abstraction uses concept similar to type-erasure or protocol witness pattern, wrapping the behaviour of concrete implementations and
delegating to them once the wrapper funcions are called.</p>

</dd>
<dt class="structure">
    <a href="/SubjectType" title="structure - SubjectType">
        Subject‚ÄãType
    </a>
</dt>
<dd>
    <p>Abstraction over passthrough subject types (<code>PassthroughSubject</code>, <code>PublishSubject</code>, <code>Signal</code>) from reactive frameworks.
This abstraction uses concept similar to type-erasure or protocol witness pattern, wrapping the behaviour of concrete implementations and
delegating to them once the wrapper funcions are called.</p>

</dd>
<dt class="structure">
    <a href="/ReplayLastSubjectType" title="structure - ReplayLastSubjectType">
        Replay‚ÄãLast‚ÄãSubject‚ÄãType
    </a>
</dt>
<dd>
    <p>Abstraction over subject types able to keep the last object (<code>CurrentValueSubject</code>, <code>BehaviorSubject</code>, <code>MutableProperty</code>, <code>Variable</code>) from
reactive frameworks.
This abstraction uses concept similar to type-erasure or protocol witness pattern, wrapping the behaviour of concrete implementations and
delegating to them once the wrapper funcions are called.</p>

</dd>
<dt class="structure">
    <a href="/ComposedMiddleware" title="structure - ComposedMiddleware">
        Composed‚ÄãMiddleware
    </a>
</dt>
<dd>
    <p>The <code>ComposedMiddleware</code> is a container of inner middlewares that are chained together in the order as they were composed. Whenever an <code>EventProtocol</code> or an <code>ActionProtocol</code> arrives to be handled by this <code>ComposedMiddleware</code>, it will delegate to its internal chain of middlewares.</p>

</dd>
<dt class="structure">
    <a href="/IdentityMiddleware" title="structure - IdentityMiddleware">
        Identity‚ÄãMiddleware
    </a>
</dt>
<dd>
    <p>The <code>IdentityMiddleware</code> won't do any operation, simply bypass actions through. It's meant to provide identity axiom
to middleware type to allow its conformance to monoid algebra. It will simply forward actions to the next middleware
in the chain or to the reducers. It can be useful for Unit Tests or for some compositions.</p>

</dd>
<dt class="structure">
    <a href="/LiftMiddleware" title="structure - LiftMiddleware">
        Lift‚ÄãMiddleware
    </a>
</dt>
<dd>
    <p>This is a container that lifts a sub-state middleware to a global state middleware.</p>

</dd>
        </dl>
    </section>
    <section id="enumerations">
        <h2>Enumerations</h2>
        <dl>
            <dt class="enumeration">
    <a href="/ShouldEmitValue" title="enumeration - ShouldEmitValue">
        Should‚ÄãEmit‚ÄãValue
    </a>
</dt>
<dd>
    <p>A predicate that determines if a state change should notify subscribers or not, by comparing previous and new states and returning a Bool true in
case it should emit it, or false in case it should not emit it.
It comes with some standard options like <code>.always</code>, <code>.never</code>, <code>.when(old, new) -&gt; Bool</code> and, for <code>Equatable</code> structures, <code>.whenDifferent</code>.</p>

</dd>
        </dl>
    </section>
    <section id="protocols">
        <h2>Protocols</h2>
        <dl>
            <dt class="protocol">
    <a href="/Middleware" title="protocol - Middleware">
        Middleware
    </a>
</dt>
<dd>
    <p>‚õì <code>Middleware</code> is a plugin, or a composition of several plugins, that are assigned to the <code>ReduxStoreProtocol</code> pipeline in order to handle each
action received (<code>InputActionType</code>), to execute side-effects in response, and eventually dispatch more actions (<code>OutputActionType</code>) in the process.
This happens before the <code>Reducer</code> to do its job.</p>

</dd>
<dt class="protocol">
    <a href="/ActionHandler" title="protocol - ActionHandler">
        Action‚ÄãHandler
    </a>
</dt>
<dd>
    <p><code>ActionHandler</code> defines a protocol for entities able to handle actions - defined by the associated type <code>ActionType</code>.</p>

</dd>
<dt class="protocol">
    <a href="/StateProvider" title="protocol - StateProvider">
        State‚ÄãProvider
    </a>
</dt>
<dd>
    <p><code>StateProvider</code> defines a protocol for entities able to offer state publishers (Combine Publisher, RxSwift Observable,
ReactiveSwift SignalProducer) of certain <code>StateType</code>, so everybody can observe the global state changes through this
container. Usually a <code>Store</code> will implement that, but it can also be a <code>StoreProjection</code> with a state that is derived from
the global source-of-truth.</p>

</dd>
<dt class="protocol">
    <a href="/StoreType" title="protocol - StoreType">
        Store‚ÄãType
    </a>
</dt>
<dd>
    <p>üè™ <code>StoreType</code> defines a protocol for a state store.</p>

</dd>
<dt class="protocol">
    <a href="/ReduxStoreProtocol" title="protocol - ReduxStoreProtocol">
        Redux‚ÄãStore‚ÄãProtocol
    </a>
</dt>
<dd>
    
</dd>
<dt class="protocol">
    <a href="/MiddlewareReaderProtocol" title="protocol - MiddlewareReaderProtocol">
        Middleware‚ÄãReader‚ÄãProtocol
    </a>
</dt>
<dd>
    <p>A protocol to generalize MiddlewareReader. Unless you look for some very special behaviour, you should use MiddlewareReader directly which
provides everything needed for your Middleware dependency injection.</p>

</dd>
<dt class="protocol">
    <a href="/Semigroup" title="protocol - Semigroup">
        Semigroup
    </a>
</dt>
<dd>
    <p>Protocol for a semigroup, any algebraic structure that allows two of its elements to be combined into one,
<code>(A, A) -&gt; A</code>, for any of its elements and keeping associativity property for all the cases, for example:
<code>(a1 &lt;&gt; a2) &lt;&gt; a3 = a1 &lt;&gt; (a2 &lt;&gt; a3)</code> for any <code>a</code>s in <code>A</code>.</p>

</dd>
<dt class="protocol">
    <a href="/Monoid" title="protocol - Monoid">
        Monoid
    </a>
</dt>
<dd>
    <p>Protocol for a monoid algebra, allowing monoidal composition. It's a <code>Semigroup</code> with identity element, element which,
when combined to any other element, will keep the other elemenet unchanged, regardless if the composition happened from
the left or from the right, for example: <code>a &lt;&gt; identity = identity &lt;&gt; a = a</code>, for any <code>a</code> in <code>A</code>.</p>

</dd>
<dt class="protocol">
    <a href="/SubscriptionType" title="protocol - SubscriptionType">
        Subscription‚ÄãType
    </a>
</dt>
<dd>
    <p>Abstraction over subscription types from reactive frameworks.
This abstraction uses concept similar to type-erasure or protocol witness pattern, wrapping the behaviour of concrete implementations and
delegating to them once the wrapper funcions are called.</p>

</dd>
<dt class="protocol">
    <a href="/SubscriptionCollection" title="protocol - SubscriptionCollection">
        Subscription‚ÄãCollection
    </a>
</dt>
<dd>
    <p>Abstraction over subscription collection (<code>DisposeBag</code> or <code>Set&lt;AnyCancellable</code> depending on your chosen reactive framework), useful for keeping
subscriptions alive while the parent class is alive, binding the lifecycle of subscriptions to the lifecycle of views, view controllers or
presenters. Subscriptions added to a subscription collection will be cancelled/disposed automatically once the collection gets deallocated,
stopping any pending operation and cleaning up the resources.
This abstraction uses concept similar to type-erasure or protocol witness pattern, wrapping the behaviour of concrete implementations and
delegating to them once the wrapper funcions are called.</p>

</dd>
        </dl>
    </section>
    <section id="typealiases">
        <h2>Typealiases</h2>
        <dl>
            <dt class="typealias">
    <a href="/SimpleEffectMiddleware" title="typealias - SimpleEffectMiddleware">
        Simple‚ÄãEffect‚ÄãMiddleware
    </a>
</dt>
<dd>
    <p>An <code>EffectMiddleware</code> with no dependencies (Void) and having Input and Output Actions as the same type (<code>SymmetricalEffectMiddleware</code>).</p>

</dd>
<dt class="typealias">
    <a href="/SymmetricalEffectMiddleware" title="typealias - SymmetricalEffectMiddleware">
        Symmetrical‚ÄãEffect‚ÄãMiddleware
    </a>
</dt>
<dd>
    <p>An <code>EffectMiddleware</code> having Input and Output Actions as the same type.</p>

</dd>
<dt class="typealias">
    <a href="/SimpleEffectMiddleware" title="typealias - SimpleEffectMiddleware">
        Simple‚ÄãEffect‚ÄãMiddleware
    </a>
</dt>
<dd>
    <p>An <code>EffectMiddleware</code> with no dependencies (Void) and having Input and Output Actions as the same type (<code>SymmetricalEffectMiddleware</code>).</p>

</dd>
<dt class="typealias">
    <a href="/SymmetricalEffectMiddleware" title="typealias - SymmetricalEffectMiddleware">
        Symmetrical‚ÄãEffect‚ÄãMiddleware
    </a>
</dt>
<dd>
    <p>An <code>EffectMiddleware</code> having Input and Output Actions as the same type.</p>

</dd>
<dt class="typealias">
    <a href="/SimpleEffectMiddleware" title="typealias - SimpleEffectMiddleware">
        Simple‚ÄãEffect‚ÄãMiddleware
    </a>
</dt>
<dd>
    <p>An <code>EffectMiddleware</code> with no dependencies (Void) and having Input and Output Actions as the same type (<code>SymmetricalEffectMiddleware</code>).</p>

</dd>
<dt class="typealias">
    <a href="/SymmetricalEffectMiddleware" title="typealias - SymmetricalEffectMiddleware">
        Symmetrical‚ÄãEffect‚ÄãMiddleware
    </a>
</dt>
<dd>
    <p>An <code>EffectMiddleware</code> having Input and Output Actions as the same type.</p>

</dd>
<dt class="typealias">
    <a href="/StoreProjection" title="typealias - StoreProjection">
        Store‚ÄãProjection
    </a>
</dt>
<dd>
    <p>Not necessarily a store implementation means that this entity holds the source-of-truth of an app. The source-of-truth
should be single a centralized store, where all the state is held. But your Views and ViewControllers not necessarily
need to access this main Store directly, they could, instead, access some &quot;proxy&quot; store that simply intermediates
all actions (inputs) and state change notifications (outputs), without actually holding the truth. For more information
on that please check <code>StoreProjection</code>, and compare it to <code>ReduxStoreBase</code>.</p>

</dd>
<dt class="typealias">
    <a href="/UnfailableSubscriberType" title="typealias - UnfailableSubscriberType">
        Unfailable‚ÄãSubscriber‚ÄãType
    </a>
</dt>
<dd>
    <p>Abstraction over subscriber/observer types from reactive frameworks.
For this specific case, the failure/error is <code>Never</code>, meaning that this subscriber can only subscribe to publishers that don't emit errors.
This abstraction uses concept similar to type-erasure or protocol witness pattern, wrapping the behaviour of concrete implementations and
delegating to them once the wrapper funcions are called.</p>

</dd>
<dt class="typealias">
    <a href="/UnfailablePublisherType" title="typealias - UnfailablePublisherType">
        Unfailable‚ÄãPublisher‚ÄãType
    </a>
</dt>
<dd>
    <p>Abstraction over publisher/observable/signal producer types from reactive frameworks.
For this specific case, the failure/error is <code>Never</code>, meaning that this publisher can't emit error.
This abstraction uses concept similar to type-erasure or protocol witness pattern, wrapping the behaviour of concrete implementations and
delegating to them once the wrapper funcions are called.</p>

</dd>
<dt class="typealias">
    <a href="/UnfailableSubject" title="typealias - UnfailableSubject">
        Unfailable‚ÄãSubject
    </a>
</dt>
<dd>
    <p>Abstraction over passthrough subject types (<code>PassthroughSubject</code>, <code>PublishSubject</code>, <code>Signal</code>) from reactive frameworks.
For this specific case, the failure/error is <code>Never</code>, meaning that this subject can't emit error.
This abstraction uses concept similar to type-erasure or protocol witness pattern, wrapping the behaviour of concrete implementations and
delegating to them once the wrapper funcions are called.</p>

</dd>
<dt class="typealias">
    <a href="/UnfailableReplayLastSubjectType" title="typealias - UnfailableReplayLastSubjectType">
        Unfailable‚ÄãReplay‚ÄãLast‚ÄãSubject‚ÄãType
    </a>
</dt>
<dd>
    <p>Abstraction over subject types able to keep the last object (<code>CurrentValueSubject</code>, <code>BehaviorSubject</code>, <code>MutableProperty</code>, <code>Variable</code>) from
reactive frameworks.
For this specific case, the failure/error is <code>Never</code>, meaning that this subject can't emit error.
This abstraction uses concept similar to type-erasure or protocol witness pattern, wrapping the behaviour of concrete implementations and
delegating to them once the wrapper funcions are called.</p>

</dd>
<dt class="typealias">
    <a href="/GetState" title="typealias - GetState">
        Get‚ÄãState
    </a>
</dt>
<dd>
    <p>Zero-argument function that returns the current state. <br/>
<code>() -&gt; StateType</code></p>

</dd>
<dt class="typealias">
    <a href="/ReduceFunction" title="typealias - ReduceFunction">
        Reduce‚ÄãFunction
    </a>
</dt>
<dd>
    <p>State reducer: takes current state and an action, computes the new state. <br/>
<code>(ActionType, StateType) -&gt; StateType</code></p>

</dd>
<dt class="typealias">
    <a href="/MutableReduceFunction" title="typealias - MutableReduceFunction">
        Mutable‚ÄãReduce‚ÄãFunction
    </a>
</dt>
<dd>
    <p>State reducer: takes inout version of the current state and an action, computes the new state changing the provided mutable state. <br/>
<code>(ActionType, inout StateType) -&gt; Void</code></p>

</dd>
        </dl>
    </section>
        </article>
    </main>

    <footer>
        <p>
    Generated on <time datetime="2020-11-08T00:34:00+0100">8. November 2020</time> using <a href="https://github.com/SwiftDocOrg/swift-doc">swift-doc</a> <span class="version">1.0.0-beta.5</span>.
</p>
    </footer>
</body>
</html>
