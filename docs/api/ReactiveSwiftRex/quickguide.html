<!DOCTYPE html>
<html lang="en">
  <head>
    <title>QuickGuide  Reference</title>
    <link rel="stylesheet" type="text/css" href="css/jazzy.css" />
    <link rel="stylesheet" type="text/css" href="css/highlight.css" />
    <meta charset='utf-8'>
    <script src="js/jquery.min.js" defer></script>
    <script src="js/jazzy.js" defer></script>
    
    <script src="js/lunr.min.js" defer></script>
    <script src="js/typeahead.jquery.js" defer></script>
    <script src="js/jazzy.search.js" defer></script>
  </head>
  <body>
    <a title="QuickGuide  Reference"></a>
    <header>
      <div class="content-wrapper">
        <p><a href="index.html">ReactiveSwiftRex 0.8.12 Docs</a> (35% documented)</p>
        <p class="header-right"><a href="https://github.com/SwiftRex/SwiftRex"><img src="img/gh.png"/>View on GitHub</a></p>
        <p class="header-right">
          <form role="search" action="search.json">
            <input type="text" placeholder="Search documentation" data-typeahead>
          </form>
        </p>
      </div>
    </header>
    <div class="content-wrapper">
      <p id="breadcrumbs">
        <a href="index.html">ReactiveSwiftRex Reference</a>
        <img id="carat" src="img/carat.png" />
        QuickGuide  Reference
      </p>
    </div>
    <div class="content-wrapper">
      <nav class="sidebar">
        <ul class="nav-groups">
          <li class="nav-group-name">
            <a href="Guides.html">Guides</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="actionenumproperties.html">ActionEnumProperties</a>
              </li>
              <li class="nav-group-task">
                <a href="combinerex.html">CombineRex</a>
              </li>
              <li class="nav-group-task">
                <a href="quickguide.html">QuickGuide</a>
              </li>
              <li class="nav-group-task">
                <a href="reactiveswiftrex.html">ReactiveSwiftRex</a>
              </li>
              <li class="nav-group-task">
                <a href="rxswiftrex.html">RxSwiftRex</a>
              </li>
              <li class="nav-group-task">
                <a href="statemanagement.html">StateManagement</a>
              </li>
              <li class="nav-group-task">
                <a href="swiftrex.html">SwiftRex</a>
              </li>
              <li class="nav-group-task">
                <a href="uikitlifetimemanagement.html">UIKitLifetimeManagement</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Classes.html">Classes</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Classes/EffectMiddleware.html">EffectMiddleware</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Extensions.html">Extensions</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Extensions/Disposable.html">Disposable</a>
              </li>
              <li class="nav-group-task">
                <a href="Extensions/Lifetime.html">Lifetime</a>
              </li>
              <li class="nav-group-task">
                <a href="Extensions/MiddlewareReader.html">MiddlewareReader</a>
              </li>
              <li class="nav-group-task">
                <a href="Extensions/PublisherType.html">PublisherType</a>
              </li>
              <li class="nav-group-task">
                <a href="Extensions/ReplayLastSubjectType.html">ReplayLastSubjectType</a>
              </li>
              <li class="nav-group-task">
                <a href="Extensions/Signal.html">Signal</a>
              </li>
              <li class="nav-group-task">
                <a href="Extensions/Signal/Observer.html">‚Äì Observer</a>
              </li>
              <li class="nav-group-task">
                <a href="Extensions/SignalProducerProtocol.html">SignalProducerProtocol</a>
              </li>
              <li class="nav-group-task">
                <a href="Extensions/SignalProtocol.html">SignalProtocol</a>
              </li>
              <li class="nav-group-task">
                <a href="Extensions/SubjectType.html">SubjectType</a>
              </li>
              <li class="nav-group-task">
                <a href="Extensions/SubscriberType.html">SubscriberType</a>
              </li>
              <li class="nav-group-task">
                <a href="Extensions/SubscriptionType.html">SubscriptionType</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Structs.html">Structures</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Structs/Effect.html">Effect</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/FireAndForget.html">FireAndForget</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Typealiases.html">Type Aliases</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Typealiases.html#/s:16ReactiveSwiftRex22SimpleEffectMiddlewarea">SimpleEffectMiddleware</a>
              </li>
              <li class="nav-group-task">
                <a href="Typealiases.html#/s:16ReactiveSwiftRex27SymmetricalEffectMiddlewarea">SymmetricalEffectMiddleware</a>
              </li>
            </ul>
          </li>
        </ul>
      </nav>
      <article class="main-content">
        <section>
          <section class="section">
            
            <h1 id='quick-guide' class='heading'>Quick Guide</h1>

<p>This is a TL;DR in case you want to start quickly, without too much theory, or in case you&rsquo;re already pretty familiar with other redux implementations. We still recommend the other topics for a deeper understanding behind SwiftRex concepts.</p>

<p>The minimum implementation is:</p>

<ul>
<li>an <code>AppAction</code> (enum)</li>
<li>an <code>AppState</code> (struct)</li>
<li>a <code>Store</code> (class)</li>
<li>an app <code>Reducer&lt;AppAction, AppState&gt;</code> (function)</li>
<li>an app <code>Middleware</code> (class).</li>
</ul>
<h2 id='index' class='heading'>Index</h2>

<ul>
<li><a href="#very-minimum-counter-example">Very minimum Counter Example</a></li>
<li><a href="#lifting-reducer">Lifting Reducer</a></li>
<li><a href="#store-projection-and-view-models">Store Projection and View Models</a></li>
<li><a href="#side-effects">Side Effects</a></li>
</ul>
<h2 id='a-href-swiftui-full-example-swiftui-full-example-a' class='heading'>- <a href="#swiftui-full-example">SwiftUI Full Example</a></h2>
<h2 id='very-minimum-counter-example' class='heading'>Very minimum Counter Example</h2>

<p>Let&rsquo;s start with a counter that has no side-effects, therefore we&rsquo;re going to use <code>IdentityMiddleware()</code> that simply ignores all events.</p>
<pre class="highlight swift"><code><span class="kd">struct</span> <span class="kt">AppState</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span>
<span class="p">}</span>

<span class="kd">enum</span> <span class="kt">AppAction</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">increment</span>
    <span class="k">case</span> <span class="n">decrement</span>
<span class="p">}</span>
</code></pre>

<p>Users can dispatch increment and decrement actions. These are expected to, evidently, increment or decrement the count in the AppState.</p>

<p>Entity responsible for mutating the state is the Reducer, let&rsquo;s create one:</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">counterReducer</span> <span class="o">=</span> <span class="kt">Reducer</span><span class="o">&lt;</span><span class="kt">AppAction</span><span class="p">,</span> <span class="kt">AppState</span><span class="o">&gt;.</span><span class="n">reduce</span> <span class="p">{</span> <span class="n">action</span><span class="p">,</span> <span class="n">state</span> <span class="k">in</span>
    <span class="k">switch</span> <span class="n">action</span> <span class="p">{</span>
    <span class="k">case</span> <span class="o">.</span><span class="nv">decrement</span><span class="p">:</span>
        <span class="n">state</span><span class="o">.</span><span class="n">count</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="k">case</span> <span class="o">.</span><span class="nv">increment</span><span class="p">:</span>
        <span class="n">state</span><span class="o">.</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>

<p>This is basically a function wrapped in a struct, and this function receives an action and an inout state, and is expected to calculate and modify that state depending on the action. An app is expected to have multiple reducers, each of them specialized in a narrow area, so composing multiple reducers is possible using <code>&lt;&gt;</code> operator, as long as they &ldquo;speak the same&rdquo; generics. If they don&rsquo;t, it&rsquo;s also easy to solve and we&rsquo;re going to see later in this quick guide, on the <a href="#lifting-reducer">Lifting Reducer</a> chapter. For now, let&rsquo;s compose all the reducers we have in a single appReducer:</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">appReducer</span> <span class="o">=</span> <span class="n">counterReducer</span> <span class="c1">// &lt;&gt; anotherReducer &lt;&gt; andYetAnotherReducer</span>
</code></pre>

<p>Only one, for now.</p>

<p>As said before, we won&rsquo;t have Middlewares in this example because we are not having any side-effects, so that&rsquo;s all we need to create a store. This time we&rsquo;re gonna use Combine, but this will be similar for any other Reactive Framework.</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">store</span> <span class="o">=</span> <span class="kt">ReduxStoreBase</span><span class="o">&lt;</span><span class="kt">AppAction</span><span class="p">,</span> <span class="kt">AppState</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="nv">subject</span><span class="p">:</span> <span class="o">.</span><span class="nf">combine</span><span class="p">(</span><span class="nv">initialValue</span><span class="p">:</span> <span class="kt">AppState</span><span class="p">(</span><span class="nv">count</span><span class="p">:</span> <span class="mi">0</span><span class="p">)),</span>
    <span class="nv">reducer</span><span class="p">:</span> <span class="n">appReducer</span><span class="p">,</span>
    <span class="nv">middleware</span><span class="p">:</span> <span class="kt">IdentityMiddleware</span><span class="p">()</span> <span class="c1">// &lt;- No side-effects yet</span>
<span class="p">)</span>
</code></pre>

<p>The subject <code>.combine(initialValue:)</code> will internally create a Combine CurrentValueSubject, for that you must be linking CombineRex. If you want to use RxSwift, please link RxSwiftRex and use <code>.rx((initialValue:)</code>, and finally for ReactiveSwift please link ReactiveSwiftRex and use <code>.reactive(initialValue:)</code>. The subject that keeps and replays the last value for each platform will be used, that way every view that subscribes to the store will automatically receive its most up-to-date state value.
We are ready to use it.</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">cancellable</span> <span class="o">=</span> <span class="n">store</span><span class="o">.</span><span class="n">statePublisher</span><span class="o">.</span><span class="n">sink</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Got new state: </span><span class="se">\(</span><span class="nv">$0</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">store</span><span class="o">.</span><span class="nf">dispatch</span><span class="p">(</span><span class="o">.</span><span class="n">increment</span><span class="p">)</span>
<span class="n">store</span><span class="o">.</span><span class="nf">dispatch</span><span class="p">(</span><span class="o">.</span><span class="n">increment</span><span class="p">)</span>
<span class="n">store</span><span class="o">.</span><span class="nf">dispatch</span><span class="p">(</span><span class="o">.</span><span class="n">decrement</span><span class="p">)</span>
<span class="n">store</span><span class="o">.</span><span class="nf">dispatch</span><span class="p">(</span><span class="o">.</span><span class="n">increment</span><span class="p">)</span>
<span class="n">store</span><span class="o">.</span><span class="nf">dispatch</span><span class="p">(</span><span class="o">.</span><span class="n">decrement</span><span class="p">)</span>
<span class="n">store</span><span class="o">.</span><span class="nf">dispatch</span><span class="p">(</span><span class="o">.</span><span class="n">decrement</span><span class="p">)</span>
<span class="n">store</span><span class="o">.</span><span class="nf">dispatch</span><span class="p">(</span><span class="o">.</span><span class="n">decrement</span><span class="p">)</span>
<span class="n">store</span><span class="o">.</span><span class="nf">dispatch</span><span class="p">(</span><span class="o">.</span><span class="n">increment</span><span class="p">)</span>
</code></pre>

<p>Usually views (either SwiftUI or UIKit ones) will subscribe to the store and update the components on every new state. The views will also dispatch events every time some user interaction happens, such as button taps, keyboard event, drag gesture, etc.
Later, we&rsquo;re going to learn how to narrow down what part of the state a View is allowed to see and what subset of actions it&rsquo;s allowed to dispatch. Or even, optionally, how to use specific ViewModel and ViewEvent that translate to AppState and AppAction so your view is completely detached from your model. For all of that, please check <a href="#store-projection-and-view-models">Store Projection and View Models</a> chapter.</p>

<hr>
<h2 id='lifting-reducer' class='heading'>Lifting Reducer</h2>

<p>However all reducers could work on the whole AppAction and AppState all the time, it&rsquo;s better to limit their scope to avoid bugs and switch/cases with <code>default</code> pattern match. Let&rsquo;s review our example above, but now we&rsquo;re going to have a CountAction which is only one possible case in a much broader AppAction.</p>
<pre class="highlight swift"><code><span class="kd">struct</span> <span class="kt">AppState</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span>
<span class="p">}</span>

<span class="kd">enum</span> <span class="kt">AppAction</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nf">count</span><span class="p">(</span><span class="kt">CountAction</span><span class="p">)</span>
    <span class="c1">// case another action category</span>
    <span class="c1">// case and another action category</span>
<span class="p">}</span>

<span class="kd">enum</span> <span class="kt">CountAction</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">increment</span>
    <span class="k">case</span> <span class="n">decrement</span>
<span class="p">}</span>
</code></pre>

<p>First of all, our Reducer doesn&rsquo;t need to see the whole AppAction if it only handles CountAction, so our reducer will only see that.
The whole AppState also seems to be too much for it, it only cares about a single property, the <code>count: Int</code>. So we can limit its state to the very bare minimum <code>Int</code> which is expected to be the count.</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">counterReducer</span> <span class="o">=</span> <span class="kt">Reducer</span><span class="o">&lt;</span><span class="kt">CountAction</span><span class="p">,</span> <span class="kt">Int</span><span class="o">&gt;.</span><span class="n">reduce</span> <span class="p">{</span> <span class="n">action</span> <span class="cm">/* : CountAction */</span><span class="p">,</span> <span class="n">state</span> <span class="cm">/* : inout Int */</span> <span class="k">in</span>
    <span class="k">switch</span> <span class="n">action</span> <span class="p">{</span> <span class="c1">// Here, action is not full AppAction, but only CountAction subset</span>
    <span class="k">case</span> <span class="o">.</span><span class="nv">decrement</span><span class="p">:</span>
        <span class="n">state</span> <span class="o">-=</span> <span class="mi">1</span> <span class="c1">// Here, state is the count property, as Int, so we can perform Math directly on it</span>
    <span class="k">case</span> <span class="o">.</span><span class="nv">increment</span><span class="p">:</span>
        <span class="n">state</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1">// Here, state is the count property, as Int, so we can perform Math directly on it</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>

<p>The generic parameters explain exactly what&rsquo;s happening there and the input types: <code>state</code> is a mere <code>inout Int</code>, so we can perform Math directly on it.</p>

<p>However, we can&rsquo;t plug this reducer any more as it&rsquo;s working on different generic types (CountAction, Int) than our store (AppAction, AppState). We want to &ldquo;lift&rdquo; this reducer to the store types (<code>CountAction -&gt; AppAction</code> and <code>Int -&gt; AppState</code>).</p>

<p>Let&rsquo;s start with the full syntax to make clear.</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">appReducer</span> <span class="o">=</span> <span class="n">counterReducer</span><span class="o">.</span><span class="nf">lift</span><span class="p">(</span>
    <span class="nv">actionGetter</span><span class="p">:</span> <span class="p">{</span> <span class="p">(</span><span class="nv">appAction</span><span class="p">:</span> <span class="kt">AppAction</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">CountAction</span><span class="p">?</span> <span class="k">in</span> <span class="c1">// Reducer will receive all AppActions of our app, we ignore most and only care if it's a CountAction. </span>
        <span class="k">guard</span> <span class="k">case</span> <span class="k">let</span> <span class="nv">AppAction</span><span class="o">.</span><span class="nf">count</span><span class="p">(</span><span class="n">countAction</span><span class="p">)</span> <span class="o">=</span> <span class="n">appAction</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">}</span> <span class="c1">// If it's not, return nil and this reduce will ignore this action.</span>
        <span class="k">return</span> <span class="n">countAction</span> <span class="c1">// Otherwise, we extract the CountAction from inside the AppAction and forwards it to the lifted reducer.</span>
    <span class="p">},</span>
    <span class="nv">stateGetter</span><span class="p">:</span> <span class="p">{</span> <span class="p">(</span><span class="nv">appState</span><span class="p">:</span> <span class="kt">AppState</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="k">in</span> <span class="c1">// When reading the state, we need to teach the lifted reducer how to extract the count (Int) from inside the whole AppState.</span>
        <span class="n">appState</span><span class="o">.</span><span class="n">count</span> <span class="c1">// And it's straightforward as we have this Int property in there. </span>
    <span class="p">},</span>
    <span class="nv">stateSetter</span><span class="p">:</span> <span class="p">{</span> <span class="p">(</span><span class="nv">appState</span><span class="p">:</span> <span class="k">inout</span> <span class="kt">AppState</span><span class="p">,</span> <span class="nv">newCount</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="k">in</span> <span class="c1">// When writing the state, we need to teach the lifted reducer how to set the new Int value into the AppState.</span>
        <span class="n">appState</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">newCount</span> <span class="c1">// As `count` variable is declared as `var`, we can simply set its value here to the new count calculated by the lifted reducer.</span>
    <span class="p">}</span>
<span class="p">)</span> <span class="c1">// &lt;&gt; anotherReducer.lift(...) &lt;&gt; .identity</span>
</code></pre>

<p>Ok, there&rsquo;s a lot happening in here, but it&rsquo;s important to show the expanded version of lift before swimming in the sugar pool, so please bear üêª with me.</p>

<p>When we lift a reducer, we need to tell the new lifted reducer how to translate local types into global types and vice-versa. Reducers are able to:</p>

<ul>
<li>receive actions (incoming)</li>
<li>receive state (incoming)</li>
<li>change state (outgoing)</li>
</ul>

<p>That&rsquo;s why we need to provide these 3 closures. More details about that are shown in the <a href="../../README.md#lifting-reducer">README Lifting Reducer Chapter</a>. However, we can use a simplified lift syntax as long as our <a href="ActionEnumProperties.md">AppAction has enum case properties</a>.</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">appReducer</span> <span class="o">=</span> <span class="n">counterReducer</span><span class="o">.</span><span class="nf">lift</span><span class="p">(</span>
    <span class="nv">action</span><span class="p">:</span> <span class="p">\</span><span class="kt">AppAction</span><span class="o">.</span><span class="n">count</span><span class="p">,</span>
    <span class="nv">state</span><span class="p">:</span> <span class="p">\</span><span class="kt">AppState</span><span class="o">.</span><span class="n">count</span>
<span class="p">)</span> <span class="c1">// &lt;&gt; anotherReducer.lift(...) &lt;&gt; .identity</span>
</code></pre>

<p>Much better, right? And because <code>count</code> is a <code>var</code> in the <code>AppState</code>, the second parameter is a <code>WritableKeyPath</code> so we don&rsquo;t need to teach the state getter and setter as two different parameters.</p>

<p>Good lifting can be challenging for those not confident with Swift generics or KeyPaths. If this is your case, download the Xcode Code Snippet for the full expanded reducer lift in <a href="CodeSnippet/LiftReducerExpanded.codesnippet">here</a>, otherwise maybe the compact reducer lift can be found in <a href="CodeSnippet/LiftReducerCompact.codesnippet">here</a>. The compact version also depends on <a href="ActionEnumProperties.md">AppAction has enum case properties</a>.</p>

<p>We can now create our Store, observe it and dispatch actions to it.</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">store</span> <span class="o">=</span> <span class="kt">ReduxStoreBase</span><span class="o">&lt;</span><span class="kt">AppAction</span><span class="p">,</span> <span class="kt">AppState</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="nv">subject</span><span class="p">:</span> <span class="o">.</span><span class="nf">combine</span><span class="p">(</span><span class="nv">initialValue</span><span class="p">:</span> <span class="kt">AppState</span><span class="p">(</span><span class="nv">count</span><span class="p">:</span> <span class="mi">0</span><span class="p">)),</span>
    <span class="nv">reducer</span><span class="p">:</span> <span class="n">appReducer</span><span class="p">,</span>
    <span class="nv">middleware</span><span class="p">:</span> <span class="kt">IdentityMiddleware</span><span class="p">()</span> <span class="c1">// &lt;- No side-effects yet</span>
<span class="p">)</span>

<span class="k">let</span> <span class="nv">cancellable</span> <span class="o">=</span> <span class="n">store</span><span class="o">.</span><span class="n">statePublisher</span><span class="o">.</span><span class="n">sink</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Got new state: </span><span class="se">\(</span><span class="nv">$0</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">store</span><span class="o">.</span><span class="nf">dispatch</span><span class="p">(</span><span class="o">.</span><span class="nf">count</span><span class="p">(</span><span class="o">.</span><span class="n">increment</span><span class="p">))</span>
<span class="n">store</span><span class="o">.</span><span class="nf">dispatch</span><span class="p">(</span><span class="o">.</span><span class="nf">count</span><span class="p">(</span><span class="o">.</span><span class="n">increment</span><span class="p">))</span>
<span class="n">store</span><span class="o">.</span><span class="nf">dispatch</span><span class="p">(</span><span class="o">.</span><span class="nf">count</span><span class="p">(</span><span class="o">.</span><span class="n">decrement</span><span class="p">))</span>
<span class="n">store</span><span class="o">.</span><span class="nf">dispatch</span><span class="p">(</span><span class="o">.</span><span class="nf">count</span><span class="p">(</span><span class="o">.</span><span class="n">increment</span><span class="p">))</span>
<span class="n">store</span><span class="o">.</span><span class="nf">dispatch</span><span class="p">(</span><span class="o">.</span><span class="n">anythingElse</span><span class="p">)</span> <span class="c1">// This one will be ignored by CountReducer, but hopefully handled by another reducer.</span>
<span class="n">store</span><span class="o">.</span><span class="nf">dispatch</span><span class="p">(</span><span class="o">.</span><span class="nf">count</span><span class="p">(</span><span class="o">.</span><span class="n">decrement</span><span class="p">))</span>
<span class="n">store</span><span class="o">.</span><span class="nf">dispatch</span><span class="p">(</span><span class="o">.</span><span class="nf">count</span><span class="p">(</span><span class="o">.</span><span class="n">decrement</span><span class="p">))</span>
<span class="n">store</span><span class="o">.</span><span class="nf">dispatch</span><span class="p">(</span><span class="o">.</span><span class="nf">count</span><span class="p">(</span><span class="o">.</span><span class="n">decrement</span><span class="p">))</span>
<span class="n">store</span><span class="o">.</span><span class="nf">dispatch</span><span class="p">(</span><span class="o">.</span><span class="nf">count</span><span class="p">(</span><span class="o">.</span><span class="n">increment</span><span class="p">))</span>
</code></pre>

<hr>
<h2 id='store-projection-and-view-models' class='heading'>Store Projection and View Models</h2>

<p>On the previous chapter we&rsquo;ve learned how to make the scope of reducers more narrow, so they can&rsquo;t mess with things they don&rsquo;t understand. That not only prevents bugs but also unlocks modularization, so reducers can be in different frameworks and lifted to the global types only in the main target.</p>

<p>Why not doing the same with Views? If Views could always talk to the full Store they:</p>

<ul>
<li>would read much more state than they will ever need</li>
<li>would get refreshed when parts of the state they don&rsquo;t even care about are changed</li>
<li>could dispatch actions for paths they were not supposed to</li>
</ul>

<p>The second issue is specially important to avoid, you don&rsquo;t want your UI reloading for nothing.</p>
<pre class="highlight swift"><code><span class="kd">struct</span> <span class="kt">CounterViewState</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">countLabelText</span><span class="p">:</span> <span class="kt">String</span>

    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">from</span><span class="p">(</span><span class="nv">appState</span><span class="p">:</span> <span class="kt">AppState</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">CounterViewState</span> <span class="p">{</span>
        <span class="c1">// Given the business model (AppState), let's translate that into flat View structs, reflecting UI element properties only </span>
        <span class="kt">CounterViewState</span><span class="p">(</span><span class="nv">countLabelText</span><span class="p">:</span> <span class="s">"</span><span class="se">\(</span><span class="n">appState</span><span class="o">.</span><span class="n">count</span><span class="se">)</span><span class="s">"</span><span class="p">)</span> <span class="c1">// TODO: Use NumberFormatter</span>
    <span class="p">}</span>
<span class="p">}</span>

 <span class="c1">// View action (everything the user inputs to the app)</span>
<span class="kd">enum</span> <span class="kt">CounterViewAction</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">plusButtonTapped</span>
    <span class="k">case</span> <span class="n">minusButtonTapped</span>

    <span class="k">var</span> <span class="nv">asAppAction</span><span class="p">:</span> <span class="kt">AppAction</span><span class="p">?</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="k">self</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">plusButtonTapped</span><span class="p">:</span> <span class="k">return</span> <span class="o">.</span><span class="nf">count</span><span class="p">(</span><span class="o">.</span><span class="n">increment</span><span class="p">)</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">minusButtonTapped</span><span class="p">:</span> <span class="k">return</span> <span class="o">.</span><span class="nf">count</span><span class="p">(</span><span class="o">.</span><span class="n">decrement</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>

<p>We start creating a completely isolated pair of State and Action only for our View. Although this is not required, it&rsquo;s how usually MVVM architectures approach backend/frontend separation and could be helpful to establish a transformation layer where number/date formatting, string localization and other UI work are done. This is completely optional, but recommended. The two functions that bridge UI types to Store types are created in the ViewState and ViewAction entities, but they could also be in a Presenter or ViewModel class if this is your way to go.</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">viewModel</span><span class="p">:</span> <span class="kt">StoreProjection</span><span class="o">&lt;</span><span class="kt">CounterViewAction</span><span class="p">,</span> <span class="kt">CounterViewState</span><span class="o">&gt;</span> <span class="o">=</span>
    <span class="n">store</span><span class="o">.</span><span class="nf">projection</span><span class="p">(</span>
        <span class="nv">action</span><span class="p">:</span> <span class="p">\</span><span class="kt">CounterViewAction</span><span class="o">.</span><span class="n">asAppAction</span><span class="p">,</span>
        <span class="nv">state</span><span class="p">:</span> <span class="kt">CounterViewState</span><span class="o">.</span><span class="nf">from</span><span class="p">(</span><span class="nv">appState</span><span class="p">:)</span>
    <span class="p">)</span>
</code></pre>

<p>Our viewModel acts as a Store, but it&rsquo;s only a projection of a Store, implementing the very same <code>StoreType</code> protocol so it works as a regular Store. But every Action or State will be transformed by that pair of functions we specified. Now, our View is completely limited to <code>CounterViewState</code> and <code>CounterViewAction</code>, and the semantic of <code>CounterViewAction</code> resemble button events instead of business logic. The same way, <code>CounterViewState</code> has formatted properties ready to be shown in a Label or SwiftUI Text without any view logic.</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">cancellable</span> <span class="o">=</span> <span class="n">viewModel</span><span class="o">.</span><span class="n">statePublisher</span><span class="o">.</span><span class="n">sink</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Got new state, should set label value to: </span><span class="se">\(</span><span class="nv">$0</span><span class="o">.</span><span class="n">countLabelText</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">viewModel</span><span class="o">.</span><span class="nf">dispatch</span><span class="p">(</span><span class="o">.</span><span class="n">plusButtonTapped</span><span class="p">)</span>
<span class="n">viewModel</span><span class="o">.</span><span class="nf">dispatch</span><span class="p">(</span><span class="o">.</span><span class="n">plusButtonTapped</span><span class="p">)</span>
<span class="n">viewModel</span><span class="o">.</span><span class="nf">dispatch</span><span class="p">(</span><span class="o">.</span><span class="n">minusButtonTapped</span><span class="p">)</span>
<span class="n">viewModel</span><span class="o">.</span><span class="nf">dispatch</span><span class="p">(</span><span class="o">.</span><span class="n">plusButtonTapped</span><span class="p">)</span>
<span class="n">viewModel</span><span class="o">.</span><span class="nf">dispatch</span><span class="p">(</span><span class="o">.</span><span class="n">minusButtonTapped</span><span class="p">)</span>
<span class="n">viewModel</span><span class="o">.</span><span class="nf">dispatch</span><span class="p">(</span><span class="o">.</span><span class="n">minusButtonTapped</span><span class="p">)</span>
<span class="n">viewModel</span><span class="o">.</span><span class="nf">dispatch</span><span class="p">(</span><span class="o">.</span><span class="n">minusButtonTapped</span><span class="p">)</span>
<span class="n">viewModel</span><span class="o">.</span><span class="nf">dispatch</span><span class="p">(</span><span class="o">.</span><span class="n">plusButtonTapped</span><span class="p">)</span>
</code></pre>

<hr>
<h2 id='side-effects' class='heading'>Side Effects</h2>

<p>So far we haven&rsquo;t seen any side-effect. Now, let&rsquo;s create a middleware that monitors shake gestures and increment the counter every time the user shakes the iPhone.</p>

<p>First of all, let&rsquo;s create an Action to start or stop the shake gesture.</p>
<pre class="highlight swift"><code><span class="kd">enum</span> <span class="kt">AppAction</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nf">count</span><span class="p">(</span><span class="kt">CountAction</span><span class="p">)</span>
    <span class="k">case</span> <span class="nf">shake</span><span class="p">(</span><span class="kt">ShakeAction</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">enum</span> <span class="kt">CountAction</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">increment</span>
    <span class="k">case</span> <span class="n">decrement</span>
<span class="p">}</span>

<span class="kd">enum</span> <span class="kt">ShakeAction</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">startMonitoring</span>
    <span class="k">case</span> <span class="n">shaken</span>
    <span class="k">case</span> <span class="n">stopMonitoring</span>
<span class="p">}</span>
</code></pre>

<p>We&rsquo;re going to use Combine but in this case a pure NotificationCenter observation would be enough.</p>
<pre class="highlight swift"><code>
<span class="kd">import</span> <span class="kt">Combine</span>
<span class="kd">import</span> <span class="kt">Foundation</span>
<span class="kd">import</span> <span class="kt">SwiftRex</span>

<span class="kd">class</span> <span class="kt">ShakeMiddleware</span><span class="p">:</span> <span class="kt">Middleware</span> <span class="p">{</span>
    <span class="c1">// start of boilerplate</span>
    <span class="c1">// there are other higher level middlewares implementations</span>
    <span class="c1">// that hide most of this code, we're showing the complete</span>
    <span class="c1">// stuff to go very basic</span>
    <span class="nf">init</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>

    <span class="kd">private</span> <span class="k">var</span> <span class="nv">getState</span><span class="p">:</span> <span class="kt">GetState</span><span class="o">&lt;</span><span class="kt">AppState</span><span class="o">&gt;</span><span class="p">?</span>
    <span class="kd">private</span> <span class="k">var</span> <span class="nv">output</span><span class="p">:</span> <span class="kt">AnyActionHandler</span><span class="o">&lt;</span><span class="kt">AppAction</span><span class="o">&gt;</span><span class="p">?</span>
    <span class="kd">func</span> <span class="nf">receiveContext</span><span class="p">(</span><span class="nv">getState</span><span class="p">:</span> <span class="kd">@escaping</span> <span class="kt">GetState</span><span class="o">&lt;</span><span class="kt">AppState</span><span class="o">&gt;</span><span class="p">,</span> <span class="nv">output</span><span class="p">:</span> <span class="kt">AnyActionHandler</span><span class="o">&lt;</span><span class="kt">AppAction</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">getState</span> <span class="o">=</span> <span class="n">getState</span>
        <span class="k">self</span><span class="o">.</span><span class="n">output</span> <span class="o">=</span> <span class="n">output</span>
    <span class="p">}</span>
    <span class="c1">// end of boilerplate</span>

    <span class="c1">// Side-effect subscription</span>
    <span class="kd">private</span> <span class="k">var</span> <span class="nv">shakeGesture</span><span class="p">:</span> <span class="kt">AnyCancellable</span><span class="p">?</span>

    <span class="kd">func</span> <span class="nf">handle</span><span class="p">(</span><span class="nv">action</span><span class="p">:</span> <span class="kt">AppAction</span><span class="p">,</span> <span class="n">from</span> <span class="nv">dispatcher</span><span class="p">:</span> <span class="kt">ActionSource</span><span class="p">,</span> <span class="nv">afterReducer</span><span class="p">:</span> <span class="k">inout</span> <span class="kt">AfterReducer</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// an action arrived, do we care about it?</span>
        <span class="k">switch</span> <span class="n">action</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">.</span><span class="nf">shake</span><span class="p">(</span><span class="o">.</span><span class="n">startMonitoring</span><span class="p">):</span>
            <span class="c1">// let's start the side-effect observation</span>
            <span class="n">shakeGesture</span> <span class="o">=</span> <span class="kt">NotificationCenter</span><span class="o">.</span><span class="k">default</span><span class="o">.</span><span class="nf">publisher</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="o">.</span><span class="n">shakeGesture</span><span class="p">)</span><span class="o">.</span><span class="n">sink</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="n">_</span> <span class="k">in</span>
                <span class="c1">// every time we detect a device shake, we dispatch a .shake(.shaken) action in response</span>
                <span class="k">self</span><span class="p">?</span><span class="o">.</span><span class="n">output</span><span class="p">?</span><span class="o">.</span><span class="nf">dispatch</span><span class="p">(</span><span class="o">.</span><span class="nf">shake</span><span class="p">(</span><span class="o">.</span><span class="n">shaken</span><span class="p">))</span>
            <span class="p">}</span>

        <span class="k">case</span> <span class="o">.</span><span class="nf">shake</span><span class="p">(</span><span class="o">.</span><span class="n">stopMonitoring</span><span class="p">):</span>
            <span class="c1">// effect cancellation, user doesn't want this any more, Combine AnyCancellable will stop that for us</span>
            <span class="n">shakeGesture</span> <span class="o">=</span> <span class="kc">nil</span>

        <span class="k">case</span> <span class="o">.</span><span class="nf">shake</span><span class="p">(</span><span class="o">.</span><span class="n">shaken</span><span class="p">):</span>
            <span class="c1">// .shake(.shaken) is an action that we dispatched ourselves, and we're receiving it back</span>
            <span class="c1">// although this extra roundtrip is optional, it helps to "tell a story" in your logs.</span>
            <span class="n">output</span><span class="p">?</span><span class="o">.</span><span class="nf">dispatch</span><span class="p">(</span><span class="o">.</span><span class="nf">count</span><span class="p">(</span><span class="o">.</span><span class="n">increment</span><span class="p">))</span>

        <span class="k">case</span> <span class="o">.</span><span class="nv">count</span><span class="p">:</span>
            <span class="c1">// we don't care about incoming count actions</span>
            <span class="k">break</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Extra stuff for this gesture</span>
<span class="kd">extension</span> <span class="kt">Notification</span><span class="o">.</span><span class="kt">Name</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="k">let</span> <span class="nv">shakeGesture</span> <span class="o">=</span> <span class="kt">Notification</span><span class="o">.</span><span class="kt">Name</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="s">"ShakeGesture"</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// For SwiftUI this is the way to go, for UIKit you can do the same in your main UIViewController</span>
<span class="kd">extension</span> <span class="kt">UIWindow</span> <span class="p">{</span>
    <span class="kd">open</span> <span class="k">override</span> <span class="kd">func</span> <span class="nf">motionEnded</span><span class="p">(</span><span class="n">_</span> <span class="nv">motion</span><span class="p">:</span> <span class="kt">UIEvent</span><span class="o">.</span><span class="kt">EventSubtype</span><span class="p">,</span> <span class="n">with</span> <span class="nv">event</span><span class="p">:</span> <span class="kt">UIEvent</span><span class="p">?)</span> <span class="p">{</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">motionEnded</span><span class="p">(</span><span class="n">motion</span><span class="p">,</span> <span class="nv">with</span><span class="p">:</span> <span class="n">event</span><span class="p">)</span>
        <span class="k">guard</span> <span class="n">motion</span> <span class="o">==</span> <span class="o">.</span><span class="n">motionShake</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
        <span class="kt">NotificationCenter</span><span class="o">.</span><span class="k">default</span><span class="o">.</span><span class="nf">post</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="o">.</span><span class="n">shakeGesture</span><span class="p">,</span> <span class="nv">object</span><span class="p">:</span> <span class="n">event</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>

<p>Let&rsquo;s use it.</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">appMiddleware</span> <span class="o">=</span> <span class="kt">ShakeMiddleware</span><span class="p">()</span> <span class="c1">// &lt;&gt; AnotherMiddleware() &lt;&gt; AndAnother()</span>

<span class="k">let</span> <span class="nv">store</span> <span class="o">=</span> <span class="kt">ReduxStoreBase</span><span class="o">&lt;</span><span class="kt">AppAction</span><span class="p">,</span> <span class="kt">AppState</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="nv">subject</span><span class="p">:</span> <span class="o">.</span><span class="nf">combine</span><span class="p">(</span><span class="nv">initialValue</span><span class="p">:</span> <span class="kt">AppState</span><span class="p">(</span><span class="nv">count</span><span class="p">:</span> <span class="mi">0</span><span class="p">)),</span>
    <span class="nv">reducer</span><span class="p">:</span> <span class="n">appReducer</span><span class="p">,</span>
    <span class="nv">middleware</span><span class="p">:</span> <span class="n">appMiddleware</span>
<span class="p">)</span>

<span class="k">let</span> <span class="nv">cancellable</span> <span class="o">=</span> <span class="n">store</span><span class="o">.</span><span class="n">statePublisher</span><span class="o">.</span><span class="n">sink</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Got new state: </span><span class="se">\(</span><span class="nv">$0</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">store</span><span class="o">.</span><span class="nf">dispatch</span><span class="p">(</span><span class="o">.</span><span class="nf">shake</span><span class="p">(</span><span class="o">.</span><span class="n">start</span><span class="p">))</span>
</code></pre>

<p>We can start the side-effect (<code>store.dispatch(.shake(.start))</code>) in response to <code>.appInForeground</code> action, and stop it (<code>store.dispatch(.shake(.stop))</code>) in response to a <code>.appInBackground</code> action. Because a middleware can dispatch functions to itself, we can use that to &ldquo;tell a store&rdquo;. Instead of simply dispatching <code>.count(.increment)</code> directly from the shake gesture closure, we decided to dispatch first a <code>.shake(.shaken)</code> and, later, in response to <code>.shake(.shaken)</code> we finally dispatch <code>.count(.increment)</code>.</p>

<p>This is not required, but helps to understand where the increment came from, not from the button tap on UI, but from a shake gesture. This also helps to debug possible problems with your side-effect frameworks.</p>

<p>You can always choose a more direct approach, and that&rsquo;s perfectly fine!</p>

<p>Finally, this Middleware is probably accessing more Actions and State than it should, we could also make it more specific to subsets of Action and State, or even ignore the state completely as we don&rsquo;t need it (in that case, it would be Void). When we do that, we can also lift middlewares in a similar way we did for reducers.</p>

<hr>
<h2 id='swiftui-full-example' class='heading'>SwiftUI Full Example</h2>

<p>SwiftRex works for UIKit, AppKit, WatchKit, SwiftUI and probably any other presentation framework, on Mac, Linux or mobile devices.
But because we are excited about SwiftUI functional programming style, let&rsquo;s implement a whole app with all features seen in this Quick Guide and some new ones, as lifting Middlewares.</p>
<pre class="highlight swift"><code><span class="kd">import</span> <span class="kt">Combine</span>
<span class="kd">import</span> <span class="kt">CombineRex</span>
<span class="kd">import</span> <span class="kt">SwiftRex</span>
<span class="kd">import</span> <span class="kt">SwiftUI</span>

<span class="kd">@main</span>
<span class="kd">struct</span> <span class="kt">ShakeAndCountApp</span><span class="p">:</span> <span class="kt">App</span> <span class="p">{</span>
    <span class="kd">@StateObject</span> <span class="k">var</span> <span class="nv">store</span> <span class="o">=</span> <span class="kt">Store</span><span class="o">.</span><span class="nf">create</span><span class="p">()</span><span class="o">.</span><span class="nf">asObservableViewModel</span><span class="p">(</span><span class="nv">initialState</span><span class="p">:</span> <span class="o">.</span><span class="n">initial</span><span class="p">)</span>

    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">Scene</span> <span class="p">{</span>
        <span class="kt">WindowGroup</span> <span class="p">{</span>
            <span class="kt">ContentView</span><span class="p">(</span><span class="nv">viewModel</span><span class="p">:</span> <span class="kt">CounterViewModel</span><span class="o">.</span><span class="nf">viewModel</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="n">store</span><span class="p">))</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// MARK: - UI</span>

<span class="c1">// MARK: View</span>
<span class="kd">struct</span> <span class="kt">ContentView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">@ObservedObject</span> <span class="k">var</span> <span class="nv">viewModel</span><span class="p">:</span> <span class="kt">ObservableViewModel</span><span class="o">&lt;</span><span class="kt">CounterViewModel</span><span class="o">.</span><span class="kt">ViewAction</span><span class="p">,</span> <span class="kt">CounterViewModel</span><span class="o">.</span><span class="kt">ViewState</span><span class="o">&gt;</span>

    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">VStack</span> <span class="p">{</span>
            <span class="kt">Text</span><span class="p">(</span><span class="n">viewModel</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">title</span><span class="p">)</span><span class="o">.</span><span class="nf">font</span><span class="p">(</span><span class="o">.</span><span class="n">largeTitle</span><span class="p">)</span><span class="o">.</span><span class="nf">padding</span><span class="p">()</span>

            <span class="kt">HStack</span> <span class="p">{</span>
                <span class="kt">Button</span><span class="p">(</span><span class="s">"-"</span><span class="p">)</span> <span class="p">{</span> <span class="n">viewModel</span><span class="o">.</span><span class="nf">dispatch</span><span class="p">(</span><span class="o">.</span><span class="n">minusButtonTap</span><span class="p">)</span> <span class="p">}</span><span class="o">.</span><span class="nf">font</span><span class="p">(</span><span class="o">.</span><span class="n">body</span><span class="p">)</span><span class="o">.</span><span class="nf">padding</span><span class="p">()</span>
                <span class="kt">Text</span><span class="p">(</span><span class="n">viewModel</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">countLabel</span><span class="p">)</span><span class="o">.</span><span class="nf">font</span><span class="p">(</span><span class="o">.</span><span class="n">title</span><span class="p">)</span><span class="o">.</span><span class="nf">padding</span><span class="p">()</span>
                <span class="kt">Button</span><span class="p">(</span><span class="s">"+"</span><span class="p">)</span> <span class="p">{</span> <span class="n">viewModel</span><span class="o">.</span><span class="nf">dispatch</span><span class="p">(</span><span class="o">.</span><span class="n">plusButtonTap</span><span class="p">)</span> <span class="p">}</span><span class="o">.</span><span class="nf">font</span><span class="p">(</span><span class="o">.</span><span class="n">body</span><span class="p">)</span><span class="o">.</span><span class="nf">padding</span><span class="p">()</span>
            <span class="p">}</span><span class="o">.</span><span class="nf">padding</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="o">.</span><span class="nf">padding</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// MARK: ViewModel</span>
<span class="kd">enum</span> <span class="kt">CounterViewModel</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">func</span> <span class="n">viewModel</span><span class="o">&lt;</span><span class="kt">S</span><span class="p">:</span> <span class="kt">StoreType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">from</span> <span class="nv">store</span><span class="p">:</span> <span class="kt">S</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">ObservableViewModel</span><span class="o">&lt;</span><span class="kt">ViewAction</span><span class="p">,</span> <span class="kt">ViewState</span><span class="o">&gt;</span> <span class="k">where</span> <span class="kt">S</span><span class="o">.</span><span class="kt">ActionType</span> <span class="o">==</span> <span class="kt">AppAction</span><span class="p">,</span> <span class="kt">S</span><span class="o">.</span><span class="kt">StateType</span> <span class="o">==</span> <span class="kt">AppState</span> <span class="p">{</span>
        <span class="n">store</span><span class="o">.</span><span class="nf">projection</span><span class="p">(</span>
            <span class="nv">action</span><span class="p">:</span> <span class="nf">from</span><span class="p">(</span><span class="nv">viewAction</span><span class="p">:),</span>
            <span class="nv">state</span><span class="p">:</span> <span class="nf">from</span><span class="p">(</span><span class="nv">appState</span><span class="p">:)</span>
        <span class="p">)</span><span class="o">.</span><span class="nf">asObservableViewModel</span><span class="p">(</span><span class="nv">initialState</span><span class="p">:</span> <span class="o">.</span><span class="n">empty</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="kd">struct</span> <span class="kt">ViewState</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">title</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"Welcome to the Redux counter"</span>
        <span class="k">let</span> <span class="nv">countLabel</span><span class="p">:</span> <span class="kt">String</span>
        <span class="kd">static</span> <span class="k">var</span> <span class="nv">empty</span><span class="p">:</span> <span class="kt">ViewState</span> <span class="p">{</span>
            <span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">countLabel</span><span class="p">:</span> <span class="s">""</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">enum</span> <span class="kt">ViewAction</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">plusButtonTap</span>
        <span class="k">case</span> <span class="n">minusButtonTap</span>
    <span class="p">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">func</span> <span class="nf">from</span><span class="p">(</span><span class="nv">viewAction</span><span class="p">:</span> <span class="kt">ViewAction</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">AppAction</span><span class="p">?</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="n">viewAction</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">plusButtonTap</span><span class="p">:</span> <span class="k">return</span> <span class="o">.</span><span class="nf">count</span><span class="p">(</span><span class="o">.</span><span class="n">increment</span><span class="p">)</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">minusButtonTap</span><span class="p">:</span> <span class="k">return</span> <span class="o">.</span><span class="nf">count</span><span class="p">(</span><span class="o">.</span><span class="n">decrement</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">func</span> <span class="nf">from</span><span class="p">(</span><span class="nv">appState</span><span class="p">:</span> <span class="kt">AppState</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">ViewState</span> <span class="p">{</span>
        <span class="kt">ViewState</span><span class="p">(</span><span class="nv">countLabel</span><span class="p">:</span> <span class="s">"</span><span class="se">\(</span><span class="n">appState</span><span class="o">.</span><span class="n">count</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// MARK: - Redux</span>

<span class="c1">// MARK: State</span>
<span class="kd">struct</span> <span class="kt">AppState</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span>

    <span class="kd">static</span> <span class="k">var</span> <span class="nv">initial</span><span class="p">:</span> <span class="kt">AppState</span> <span class="p">{</span>
        <span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">count</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// MARK: Action</span>
<span class="kd">enum</span> <span class="kt">AppAction</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nf">count</span><span class="p">(</span><span class="kt">CountAction</span><span class="p">)</span>
    <span class="k">case</span> <span class="nf">shake</span><span class="p">(</span><span class="kt">ShakeAction</span><span class="p">)</span>
    <span class="k">case</span> <span class="nf">appLifecycle</span><span class="p">(</span><span class="kt">AppLifecycleAction</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">enum</span> <span class="kt">CountAction</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">increment</span>
    <span class="k">case</span> <span class="n">decrement</span>
<span class="p">}</span>
<span class="kd">enum</span> <span class="kt">ShakeAction</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">startMonitoring</span>
    <span class="k">case</span> <span class="n">shaken</span>
    <span class="k">case</span> <span class="n">stopMonitoring</span>
<span class="p">}</span>
<span class="kd">public</span> <span class="kd">enum</span> <span class="kt">AppLifecycleAction</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">start</span>
    <span class="k">case</span> <span class="n">willEnterForeground</span>
    <span class="k">case</span> <span class="n">didEnterBackground</span>
<span class="p">}</span>

<span class="c1">// MARK: Reducer</span>
<span class="k">let</span> <span class="nv">counterReducer</span> <span class="o">=</span> <span class="kt">Reducer</span><span class="o">&lt;</span><span class="kt">CountAction</span><span class="p">,</span> <span class="kt">Int</span><span class="o">&gt;.</span><span class="n">reduce</span> <span class="p">{</span> <span class="n">action</span><span class="p">,</span> <span class="n">state</span> <span class="k">in</span>
    <span class="k">switch</span> <span class="n">action</span> <span class="p">{</span>
    <span class="k">case</span> <span class="o">.</span><span class="nv">decrement</span><span class="p">:</span>
        <span class="n">state</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="k">case</span> <span class="o">.</span><span class="nv">increment</span><span class="p">:</span>
        <span class="n">state</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// MARK: Middleware</span>
<span class="kd">class</span> <span class="kt">ShakeMiddleware</span><span class="p">:</span> <span class="kt">Middleware</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="k">var</span> <span class="nv">shakeGesture</span><span class="p">:</span> <span class="kt">AnyCancellable</span><span class="p">?</span>
    <span class="kd">private</span> <span class="k">var</span> <span class="nv">output</span><span class="p">:</span> <span class="kt">AnyActionHandler</span><span class="o">&lt;</span><span class="kt">ShakeAction</span><span class="o">&gt;</span><span class="p">?</span>
    <span class="kd">func</span> <span class="nf">receiveContext</span><span class="p">(</span><span class="nv">getState</span><span class="p">:</span> <span class="kd">@escaping</span> <span class="kt">GetState</span><span class="o">&lt;</span><span class="kt">Void</span><span class="o">&gt;</span><span class="p">,</span> <span class="nv">output</span><span class="p">:</span> <span class="kt">AnyActionHandler</span><span class="o">&lt;</span><span class="kt">ShakeAction</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">output</span> <span class="o">=</span> <span class="n">output</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">handle</span><span class="p">(</span><span class="nv">action</span><span class="p">:</span> <span class="kt">ShakeAction</span><span class="p">,</span> <span class="n">from</span> <span class="nv">dispatcher</span><span class="p">:</span> <span class="kt">ActionSource</span><span class="p">,</span> <span class="nv">afterReducer</span><span class="p">:</span> <span class="k">inout</span> <span class="kt">AfterReducer</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="n">action</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">startMonitoring</span><span class="p">:</span>
            <span class="n">shakeGesture</span> <span class="o">=</span> <span class="kt">NotificationCenter</span><span class="o">.</span><span class="k">default</span><span class="o">.</span><span class="nf">publisher</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="o">.</span><span class="n">shakeGesture</span><span class="p">)</span><span class="o">.</span><span class="n">sink</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="n">_</span> <span class="k">in</span>
                <span class="k">self</span><span class="p">?</span><span class="o">.</span><span class="n">output</span><span class="p">?</span><span class="o">.</span><span class="nf">dispatch</span><span class="p">(</span><span class="o">.</span><span class="n">shaken</span><span class="p">)</span>
            <span class="p">}</span>

        <span class="k">case</span> <span class="o">.</span><span class="nv">stopMonitoring</span><span class="p">:</span>
            <span class="n">shakeGesture</span> <span class="o">=</span> <span class="kc">nil</span>

        <span class="k">case</span> <span class="o">.</span><span class="nv">shaken</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">class</span> <span class="kt">AppLifecycleMiddleware</span><span class="p">:</span> <span class="kt">Middleware</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="k">var</span> <span class="nv">lifecycleSubscription</span><span class="p">:</span> <span class="kt">AnyCancellable</span><span class="p">?</span>
    <span class="kd">private</span> <span class="k">var</span> <span class="nv">output</span><span class="p">:</span> <span class="kt">AnyActionHandler</span><span class="o">&lt;</span><span class="kt">AppLifecycleAction</span><span class="o">&gt;</span><span class="p">?</span>
    <span class="kd">func</span> <span class="nf">receiveContext</span><span class="p">(</span><span class="nv">getState</span><span class="p">:</span> <span class="kd">@escaping</span> <span class="kt">GetState</span><span class="o">&lt;</span><span class="kt">Void</span><span class="o">&gt;</span><span class="p">,</span> <span class="nv">output</span><span class="p">:</span> <span class="kt">AnyActionHandler</span><span class="o">&lt;</span><span class="kt">AppLifecycleAction</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">output</span> <span class="o">=</span> <span class="n">output</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">handle</span><span class="p">(</span><span class="nv">action</span><span class="p">:</span> <span class="kt">AppLifecycleAction</span><span class="p">,</span> <span class="n">from</span> <span class="nv">dispatcher</span><span class="p">:</span> <span class="kt">ActionSource</span><span class="p">,</span> <span class="nv">afterReducer</span><span class="p">:</span> <span class="k">inout</span> <span class="kt">AfterReducer</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="n">action</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">start</span><span class="p">:</span>
            <span class="n">lifecycleSubscription</span> <span class="o">=</span> <span class="nf">lifecyclePublisher</span><span class="p">()</span><span class="o">.</span><span class="n">sink</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="n">event</span> <span class="k">in</span>
                <span class="k">self</span><span class="p">?</span><span class="o">.</span><span class="n">output</span><span class="p">?</span><span class="o">.</span><span class="nf">dispatch</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="k">case</span> <span class="o">.</span><span class="n">didEnterBackground</span><span class="p">,</span> <span class="o">.</span><span class="nv">willEnterForeground</span><span class="p">:</span> <span class="k">break</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">lifecyclePublisher</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">AnyPublisher</span><span class="o">&lt;</span><span class="kt">AppLifecycleAction</span><span class="p">,</span> <span class="kt">Never</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">nc</span> <span class="o">=</span> <span class="kt">NotificationCenter</span><span class="o">.</span><span class="k">default</span>
        <span class="k">let</span> <span class="nv">foregroundPublisher</span> <span class="o">=</span> <span class="n">nc</span>
            <span class="o">.</span><span class="nf">publisher</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="kt">UIApplication</span><span class="o">.</span><span class="n">willEnterForegroundNotification</span><span class="p">)</span>
            <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">_</span> <span class="k">in</span> <span class="kt">AppLifecycleAction</span><span class="o">.</span><span class="n">willEnterForeground</span> <span class="p">}</span>
        <span class="k">let</span> <span class="nv">backgroundPublisher</span> <span class="o">=</span> <span class="n">nc</span>
            <span class="o">.</span><span class="nf">publisher</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="kt">UIApplication</span><span class="o">.</span><span class="n">didEnterBackgroundNotification</span><span class="p">)</span>
            <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">_</span> <span class="k">in</span> <span class="kt">AppLifecycleAction</span><span class="o">.</span><span class="n">didEnterBackground</span> <span class="p">}</span>
        <span class="k">return</span> <span class="kt">Publishers</span><span class="o">.</span><span class="kt">Merge</span><span class="p">(</span><span class="n">foregroundPublisher</span><span class="p">,</span> <span class="n">backgroundPublisher</span><span class="p">)</span>
            <span class="o">.</span><span class="nf">eraseToAnyPublisher</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">class</span> <span class="kt">LoggerMiddleware</span><span class="p">:</span> <span class="kt">Middleware</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="k">var</span> <span class="nv">getState</span><span class="p">:</span> <span class="kt">GetState</span><span class="o">&lt;</span><span class="kt">AppState</span><span class="o">&gt;</span><span class="p">?</span>
    <span class="kd">func</span> <span class="nf">receiveContext</span><span class="p">(</span><span class="nv">getState</span><span class="p">:</span> <span class="kd">@escaping</span> <span class="kt">GetState</span><span class="o">&lt;</span><span class="kt">AppState</span><span class="o">&gt;</span><span class="p">,</span> <span class="nv">output</span><span class="p">:</span> <span class="kt">AnyActionHandler</span><span class="o">&lt;</span><span class="kt">Never</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">getState</span> <span class="o">=</span> <span class="n">getState</span>
    <span class="p">}</span>
    <span class="c1">// TODO: Not production ready, don't use this in release builds</span>
    <span class="kd">func</span> <span class="nf">handle</span><span class="p">(</span><span class="nv">action</span><span class="p">:</span> <span class="kt">AppAction</span><span class="p">,</span> <span class="n">from</span> <span class="nv">dispatcher</span><span class="p">:</span> <span class="kt">ActionSource</span><span class="p">,</span> <span class="nv">afterReducer</span><span class="p">:</span> <span class="k">inout</span> <span class="kt">AfterReducer</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">getState</span> <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="n">getState</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>

        <span class="k">let</span> <span class="nv">stateBefore</span> <span class="o">=</span> <span class="nf">getState</span><span class="p">()</span>
        <span class="n">afterReducer</span> <span class="o">=</span> <span class="o">.</span><span class="k">do</span> <span class="p">{</span>
            <span class="k">let</span> <span class="nv">stateAfter</span> <span class="o">=</span> <span class="nf">getState</span><span class="p">()</span>
            <span class="nf">print</span><span class="p">(</span><span class="s">"***"</span><span class="p">)</span>
            <span class="k">defer</span> <span class="p">{</span> <span class="nf">print</span><span class="p">(</span><span class="s">"***</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span> <span class="p">}</span>

            <span class="nf">print</span><span class="p">(</span><span class="s">"Action: </span><span class="se">\(</span><span class="n">action</span><span class="se">)</span><span class="s"> from </span><span class="se">\(</span><span class="n">dispatcher</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
            <span class="k">guard</span> <span class="n">stateBefore</span> <span class="o">!=</span> <span class="n">stateAfter</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
            <span class="nf">print</span><span class="p">(</span><span class="s">"Old State: </span><span class="se">\(</span><span class="n">stateBefore</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
            <span class="nf">print</span><span class="p">(</span><span class="s">"New State: </span><span class="se">\(</span><span class="n">stateAfter</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// We are creating this middleware to bridge different kinds of events, translating events from one type to another</span>
<span class="kd">class</span> <span class="kt">BridgeMiddleware</span><span class="p">:</span> <span class="kt">Middleware</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="k">var</span> <span class="nv">output</span><span class="p">:</span> <span class="kt">AnyActionHandler</span><span class="o">&lt;</span><span class="kt">AppAction</span><span class="o">&gt;</span><span class="p">?</span>
    <span class="kd">func</span> <span class="nf">receiveContext</span><span class="p">(</span><span class="nv">getState</span><span class="p">:</span> <span class="kd">@escaping</span> <span class="kt">GetState</span><span class="o">&lt;</span><span class="kt">Void</span><span class="o">&gt;</span><span class="p">,</span> <span class="nv">output</span><span class="p">:</span> <span class="kt">AnyActionHandler</span><span class="o">&lt;</span><span class="kt">AppAction</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">output</span> <span class="o">=</span> <span class="n">output</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">handle</span><span class="p">(</span><span class="nv">action</span><span class="p">:</span> <span class="kt">AppAction</span><span class="p">,</span> <span class="n">from</span> <span class="nv">dispatcher</span><span class="p">:</span> <span class="kt">ActionSource</span><span class="p">,</span> <span class="nv">afterReducer</span><span class="p">:</span> <span class="k">inout</span> <span class="kt">AfterReducer</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="n">action</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">.</span><span class="nf">appLifecycle</span><span class="p">(</span><span class="o">.</span><span class="n">willEnterForeground</span><span class="p">):</span> <span class="n">output</span><span class="p">?</span><span class="o">.</span><span class="nf">dispatch</span><span class="p">(</span><span class="o">.</span><span class="nf">shake</span><span class="p">(</span><span class="o">.</span><span class="n">startMonitoring</span><span class="p">))</span>
        <span class="k">case</span> <span class="o">.</span><span class="nf">appLifecycle</span><span class="p">(</span><span class="o">.</span><span class="n">didEnterBackground</span><span class="p">):</span> <span class="n">output</span><span class="p">?</span><span class="o">.</span><span class="nf">dispatch</span><span class="p">(</span><span class="o">.</span><span class="nf">shake</span><span class="p">(</span><span class="o">.</span><span class="n">stopMonitoring</span><span class="p">))</span>
        <span class="k">case</span> <span class="o">.</span><span class="nf">shake</span><span class="p">(</span><span class="o">.</span><span class="n">shaken</span><span class="p">):</span> <span class="n">output</span><span class="p">?</span><span class="o">.</span><span class="nf">dispatch</span><span class="p">(</span><span class="o">.</span><span class="nf">count</span><span class="p">(</span><span class="o">.</span><span class="n">increment</span><span class="p">))</span>
        <span class="k">default</span><span class="p">:</span> <span class="k">break</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// MARK: Store</span>
<span class="kd">class</span> <span class="kt">Store</span><span class="p">:</span> <span class="kt">ReduxStoreBase</span><span class="o">&lt;</span><span class="kt">AppAction</span><span class="p">,</span> <span class="kt">AppState</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">create</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Store</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">store</span> <span class="o">=</span> <span class="kt">Store</span><span class="p">(</span>
            <span class="nv">subject</span><span class="p">:</span> <span class="o">.</span><span class="nf">combine</span><span class="p">(</span><span class="nv">initialValue</span><span class="p">:</span> <span class="kt">AppState</span><span class="p">(</span><span class="nv">count</span><span class="p">:</span> <span class="mi">0</span><span class="p">)),</span>
            <span class="nv">reducer</span><span class="p">:</span> <span class="n">counterReducer</span><span class="o">.</span><span class="nf">lift</span><span class="p">(</span>
                <span class="nv">action</span><span class="p">:</span> <span class="p">\</span><span class="kt">AppAction</span><span class="o">.</span><span class="n">count</span><span class="p">,</span>
                <span class="nv">state</span><span class="p">:</span> <span class="p">\</span><span class="kt">AppState</span><span class="o">.</span><span class="n">count</span>
            <span class="p">),</span>
            <span class="nv">middleware</span><span class="p">:</span>
                <span class="kt">ShakeMiddleware</span><span class="p">()</span><span class="o">.</span><span class="nf">lift</span><span class="p">(</span>
                    <span class="nv">inputAction</span><span class="p">:</span> <span class="p">\</span><span class="kt">AppAction</span><span class="o">.</span><span class="n">shake</span><span class="p">,</span>
                    <span class="nv">outputAction</span><span class="p">:</span> <span class="kt">AppAction</span><span class="o">.</span><span class="n">shake</span><span class="p">,</span>
                    <span class="nv">state</span><span class="p">:</span> <span class="n">ignore</span>
                <span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="kt">AppLifecycleMiddleware</span><span class="p">()</span><span class="o">.</span><span class="nf">lift</span><span class="p">(</span>
                    <span class="nv">inputAction</span><span class="p">:</span> <span class="p">\</span><span class="kt">AppAction</span><span class="o">.</span><span class="n">appLifecycle</span><span class="p">,</span>
                    <span class="nv">outputAction</span><span class="p">:</span> <span class="kt">AppAction</span><span class="o">.</span><span class="n">appLifecycle</span><span class="p">,</span>
                    <span class="nv">state</span><span class="p">:</span> <span class="n">ignore</span>
                <span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="kt">BridgeMiddleware</span><span class="p">()</span><span class="o">.</span><span class="nf">lift</span><span class="p">(</span>
                    <span class="nv">state</span><span class="p">:</span> <span class="n">ignore</span>
                <span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="kt">LoggerMiddleware</span><span class="p">()</span><span class="o">.</span><span class="nf">lift</span><span class="p">(</span><span class="nv">outputAction</span><span class="p">:</span> <span class="n">absurd</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">store</span><span class="o">.</span><span class="nf">dispatch</span><span class="p">(</span><span class="o">.</span><span class="nf">appLifecycle</span><span class="p">(</span><span class="o">.</span><span class="n">start</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">store</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// MARK: - Boilerplate</span>

<span class="c1">// MARK: Functional helpers</span>
<span class="kd">func</span> <span class="n">ignore</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">t</span><span class="p">:</span> <span class="kt">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Void</span> <span class="p">{</span> <span class="p">}</span>
<span class="kd">func</span> <span class="n">identity</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">t</span><span class="p">:</span> <span class="kt">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">T</span> <span class="p">{</span> <span class="n">t</span> <span class="p">}</span>
<span class="kd">func</span> <span class="n">absurd</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">never</span><span class="p">:</span> <span class="kt">Never</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">T</span> <span class="p">{</span> <span class="p">}</span>

<span class="c1">// MARK: SwiftUI limitations workaround</span>
<span class="kd">extension</span> <span class="kt">UIWindow</span> <span class="p">{</span>
    <span class="kd">open</span> <span class="k">override</span> <span class="kd">func</span> <span class="nf">motionEnded</span><span class="p">(</span><span class="n">_</span> <span class="nv">motion</span><span class="p">:</span> <span class="kt">UIEvent</span><span class="o">.</span><span class="kt">EventSubtype</span><span class="p">,</span> <span class="n">with</span> <span class="nv">event</span><span class="p">:</span> <span class="kt">UIEvent</span><span class="p">?)</span> <span class="p">{</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">motionEnded</span><span class="p">(</span><span class="n">motion</span><span class="p">,</span> <span class="nv">with</span><span class="p">:</span> <span class="n">event</span><span class="p">)</span>
        <span class="k">guard</span> <span class="n">motion</span> <span class="o">==</span> <span class="o">.</span><span class="n">motionShake</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
        <span class="kt">NotificationCenter</span><span class="o">.</span><span class="k">default</span><span class="o">.</span><span class="nf">post</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="o">.</span><span class="n">shakeGesture</span><span class="p">,</span> <span class="nv">object</span><span class="p">:</span> <span class="n">event</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">Notification</span><span class="o">.</span><span class="kt">Name</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="k">let</span> <span class="nv">shakeGesture</span> <span class="o">=</span> <span class="kt">Notification</span><span class="o">.</span><span class="kt">Name</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="s">"ShakeGesture"</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// MARK: Action Enum Properties (use Sourcery for boilerplate code generation)</span>
<span class="kd">extension</span> <span class="kt">AppAction</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="k">var</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">CountAction</span><span class="p">?</span> <span class="p">{</span>
        <span class="k">guard</span> <span class="k">case</span> <span class="kd">let</span> <span class="o">.</span><span class="nf">count</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">}</span>
        <span class="k">return</span> <span class="n">value</span>
    <span class="p">}</span>
    <span class="kd">public</span> <span class="k">var</span> <span class="nv">shake</span><span class="p">:</span> <span class="kt">ShakeAction</span><span class="p">?</span> <span class="p">{</span>
        <span class="k">guard</span> <span class="k">case</span> <span class="kd">let</span> <span class="o">.</span><span class="nf">shake</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">}</span>
        <span class="k">return</span> <span class="n">value</span>
    <span class="p">}</span>
    <span class="kd">public</span> <span class="k">var</span> <span class="nv">appLifecycle</span><span class="p">:</span> <span class="kt">AppLifecycleAction</span><span class="p">?</span> <span class="p">{</span>
        <span class="k">guard</span> <span class="k">case</span> <span class="kd">let</span> <span class="o">.</span><span class="nf">appLifecycle</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">}</span>
        <span class="k">return</span> <span class="n">value</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>

          </section>
        </section>
        <section id="footer">
          <p>&copy; 2022 <a class="link" href="https://github.com/SwiftRex/SwiftRex" target="_blank" rel="external">SwiftRex</a>. All rights reserved. (Last updated: 2022-04-02)</p>
          <p>Generated by <a class="link" href="https://github.com/realm/jazzy" target="_blank" rel="external">jazzy ‚ô™‚ô´ v0.13.7</a>, a <a class="link" href="https://realm.io" target="_blank" rel="external">Realm</a> project.</p>
        </section>
      </article>
    </div>
  </body>
</div>
</html>
